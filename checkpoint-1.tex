% Created 2015-03-12 Thu 15:39
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{fullpage}
\usepackage{fullpage}
\author{Xia Wu\\ \texttt{xiawu@buffalo.edu} \and Xingxiao Yuan\\ \texttt{xingxiao@buffalo.edu} \and Michael Wehar\\ \texttt{mwehar@buffalo.edu} \and Yihong Chen\\ \texttt{ychen78@buffalo.edu}}
\date{\today}
\title{Empirical assessment of the real-time capabilities of Android\\\large CSE-605 Checkpoint 1 - Rex}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 25.0.50.18 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\tableofcontents


\section{{\bfseries\sffamily TODO} Introduction}
\label{sec-1}
We will measure the predictability of Android.
How far ordinary Android system between Real-time system.

\section{{\bfseries\sffamily TODO} Android Components}
\label{sec-2}
\begin{itemize}
\item Intents and Intent Filters (receivers)

We will evaluate intent delivery mechanism of Android.
The intents will appear for almost all multiple processes experiments.

\item Activities and App Widgets

We will not directly evaluate activities and app widgets because they're only related with UI,
it's hard to produce convincible result because there're too many elements out of control,
like the GPU power, the screen resolution.

\item Services

We will not directly evalute services as well. The reason is same as activities.
\item Content Providers

We will evalute content providers related \textbf{Garbage Collector}, \textbf{Synchronization},
and \textbf{Scheduler}. Because it's shared data mechanism Android provied.
\end{itemize}


\begin{itemize}
\item Processes and Threads

We will evaluate processes and threads directly.
They're both our targets and mechanisms to use.
\end{itemize}

\section{Intents/Receivers}
\label{sec-3}
\subsection{Single Process}
\label{sec-3-1}
To directly evaluate intents and receivers on
single process deosn't make sense.
But this can provide \textbf{baseline for our experiments}.
We can compare the results of same experiment on single process
and multiple processes.
Then we can get reasoning of different behaviour.

\subsection{Multiple Processes}
\label{sec-3-2}
We can use process(es) to generate bunch of intents, then use other
process(es) to receive the intents.
In addition, there're always background process(es) with some computation
to produce pressure for Android system.
So we can evaluate the order and time of intent delivery.
It can provide some pressure for \textbf{Garbage Collector}, \textbf{Synchronization}, and \textbf{Scheduler}.

\subsubsection{Garbage Collector}
\label{sec-3-2-1}
We can use one sender and one receiver to test Garbage Collector,
So we can evaluate how garbage collector works:
\begin{itemize}
\item frequency of grabage collection and memory pressure
\item running time of grabage collection and memory pressure
\end{itemize}

The memory pressure should contains different \label{Memory-Pressure-Types}types:
\begin{center}
\begin{tabular}{l|lll}
 & big objects & medium objects & small objects\\
\hline
long live time & x & x & x\\
short live time & x & x & x\\
\end{tabular}
\end{center}

So where pressure come from?
To evalute the behavior of Android system, it need some pressure for
different components. So that we can infer the predictability of different
conponents, and the interaction between different components.
The pressure can come from:

\begin{itemize}
\item Other background process(es) with computation
\item Computation inside senders
\item Computation inside receivers
\end{itemize}

We will divide our experiments into three phases:

Phase 1. we only have pressure from background process(es).
It's easier to implement and tune for different \hyperref[Memory-Pressure-Types]{memory pressure types}.

Phase 2. we'll add additional computation to senders and receivers to compare
whether computation source affect Android's performance.

Phase 3. we combined the different pressure together to get final evaluation.

The computation can be the task from SPECjvm2008 (Java Virtual Machine Benchmark) or DaCapo Benchmark.
In addition, we can assoicate the \hyperref[Parcelable/Serializable]{Parcelable vs. Serializable} with experiment phase 3.

\subsubsection{Synchronization}
\label{sec-3-2-2}
This task need other Android components.
Because we can not pass an object as extra of an intent, we need serialize the object first.
So there no directly synchronized mechanism between sender and receiver,
but we can pass some metadata to let receivers use something need synchronization like \textbf{Content Provider}. We'll discuss in next section.

\subsubsection{Scheduler}
\label{sec-3-2-3}
We can use multiple background processes to provide pressure for scheduler.
Then we use the order of intent delivery to evaluate scheduler and intent delivery mechanism. More details can be found in Section \hyperref[Processes/Threads]{Processes/Threads}.

\section{{\bfseries\sffamily TODO} Content Providers}
\label{sec-4}

\section{{\bfseries\sffamily TODO} \label{Processes/Threads}Processes/Threads}
\label{sec-5}

\section{{\bfseries\sffamily TODO} AlarmManager}
\label{sec-6}
It's a critical factor for real-time system.

\section{{\bfseries\sffamily TODO} \label{Parcelable/Serializable}Parcelable/Serializable}
\label{sec-7}
According to this \href{http://www.developerphil.com/parcelable-vs-serializable/}{blog}, parcelable mechanism have 10 times better performance than serializable mechanism.
But parcelable need developers to implement writeToParcel and createFromParcel manually.
So parcelable can save the overhead to iterate all fields of object.
But we can compare the two mechanisms by how much pressure they generate to garbage collector.

The approach is to pass same amount of objects from one process to another process (either the same process or alien),
then we compare the different behaviors of garbage collector.
It's possible to evaluate scheduler as well.
% Emacs 25.0.50.18 (Org mode 8.2.10)
\end{document}